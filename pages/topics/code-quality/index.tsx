import Head from 'next/head'

import { Space, Typography, Divider, List, Collapse } from 'antd'

import Layout from 'components/Layout/Layout'

import styles from '../Topic.module.css'

const defaultOpenedSections = [
  'unit',
  'integration',
  'e2e',
  'acceptance',
  'API',
  'UI',
  'pyramid',
]

export default function CodeQuality() {
  return (
    <Layout>
      <Head>
        <title>Code quality</title>
        <meta name='description' content='Generated by create next app' />
        <link rel='icon' href='/favicon.ico' />
      </Head>

      <main>
        <Space direction='vertical' className={styles.rootCard}>
          <Typography.Title level={3}>Code quality</Typography.Title>

          <Divider orientation='left' dashed={true}>
            What is code quality
          </Divider>
          <Typography.Text>
            Code quality defines code that is good (high quality) â€” and code
            that is bad (low quality).
          </Typography.Text>
          <List bordered={true}>
            <List.Item>Extensibility</List.Item>
            <List.Item>Maintainability</List.Item>
            <List.Item>Readability</List.Item>
            <List.Item>Clarity</List.Item>
            <List.Item>Efficiency</List.Item>
            <List.Item>Documentation</List.Item>
          </List>

          <Divider orientation='left' dashed={true}>
            Testing
          </Divider>

          <Collapse bordered={true} defaultActiveKey={defaultOpenedSections}>
            <Collapse.Panel header='Unit testing' key='unit'>
              <Space direction='vertical' className={styles.rootCard}>
                <Typography.Text>
                  These tests are focused on each specific unit, and if we have
                  dependancy we just mock it.
                </Typography.Text>
                <Collapse bordered={false}>
                  <Collapse.Panel header='FIRST' key='FIRST'>
                    Tests should be fast(F). Tested unit should not be dependant
                    on other units, those should be mocked(Intependant). The
                    result of the test should be the same over different outer
                    conditions(Repeatable). Test should have boolean output for
                    fail/pass(Self-Validating). The tests should be written
                    before code itself, only for TDD (Timely)
                  </Collapse.Panel>
                  <Collapse.Panel header='Coverage' key='coverage'>
                    Code Coverage allows us to track how much of our code is
                    being covered with tests, are how good our tests are. It
                    consists of function/statement/branches/condition/line
                    coverages. 80% coverage is considered to be optimal, because
                    riching higher percent can be challenging.
                  </Collapse.Panel>
                </Collapse>
              </Space>
            </Collapse.Panel>
            <Collapse.Panel header='Integration testing' key='integration'>
              These tests are focused on interaction among units
            </Collapse.Panel>
            <Collapse.Panel header='E2E testing' key='e2e'>
              These tests emulate human-like behaviour, and test app from user
              perspective. With browser/backend interactions
            </Collapse.Panel>
            <Collapse.Panel header='Acceptance testing' key='acceptance'>
              Acceptance testing is testing by acceptance cretirea
            </Collapse.Panel>
            <Collapse.Panel header='API testing' key='API'>
              API testing is focused on the quality of backend API requests. One
              of possible way to do this is Postman.
            </Collapse.Panel>
            <Collapse.Panel header='UI testing' key='UI'>
              UI testing is focused on user interface, without real backend
              requests. Can be considered as Unit testing
            </Collapse.Panel>
            <Collapse.Panel header='Testing pyramid' key='pyramid'>
              Testing pyramid is showing relative amount of tests that project
              should have. At the very bottom we have unit tests, these are the
              most cheapest tests to write and they can show exact place of the
              issue. In the middle we have integration tests, which are harder
              and therefore we have less of these. And at the top we have most
              expensive tests - E2E tests, that should only cover certain
              highest priority flows
            </Collapse.Panel>
          </Collapse>

          <Divider orientation='left' dashed={true}>
            Style guide
          </Divider>
          <Typography.Text>
            Styleguide is an agreement among developers regarding the way code
            is developed. There are some tools which allows automatic
            check(ESlint, Prettier), however there still might be uncovered
            cases for which we need documentation with agreed solutions
          </Typography.Text>
          <Divider orientation='left' dashed={true}>
            Typescript
          </Divider>
          <Typography.Text>
            Typescript is programming language, which is based JS and adds type
            system. TypeScript provides type checks, preventing some bugs from
            appearing. Overall, typescript is good for long-term solutions, the
            more your code covered in TypeScript the easier it's to maintain
          </Typography.Text>
          <Divider orientation='left' dashed={true}>
            Code complexity
          </Divider>
          <Typography.Text>
            The fewer the paths through a piece of code, and the less complex
            those paths are, the lower the Cyclomatic Complexity
          </Typography.Text>

          <Divider orientation='left' dashed={true}>
            Code smells
          </Divider>
          <Typography.Text>
            Sometimes, we can "see" that our code smells, it's running low on
            code quality. There are different types of smell: huge
            classes/functions/parameters, code whichperpetuate modification our
            code, rubbish-code that is not used/duplicates other code/useless
            comments, insufficient relation among code modules.
          </Typography.Text>
          <Divider orientation='left' dashed={true}>
            Tools
          </Divider>
          <Typography.Text>
            There different tools to ensure certain level of quality. We can use
            pre-commit and pre-push hook locally, use pipelines after code is
            beign pushed, where we can run linters/tests/type checks/sonarqube
          </Typography.Text>
          <Divider orientation='left' dashed={true}>
            Code review
          </Divider>
          <Typography.Text>
            Code review is a process, where some developers analyse code written
            by another developer. There 2 basic types of review:
            prepush/postpush. Normally, we use postpush, where we check code
            after branch was publish to repository. During code review, we check
            code quality that is not covered by tools. We are look for some
            "code smell" here and some common issues of our project development,
            that are gathered with expirience.
          </Typography.Text>
          <Divider orientation='left' dashed={true}>
            Technical Debt
          </Divider>
          <Typography.Text>
            Technical Debt are tasks, which main priority to improve code
            quality. It can appear due to different reasons. Sometimes it can be
            missed by developer/tools/reviewers and we discover it later, it
            starts to smell. Sometimes, we make a decision to leave tech debt,
            when are limited in resources or when we need to introduce bug fixes
            for code, that will be removed soon
          </Typography.Text>
          <Divider orientation='left' dashed={true}>
            TDD/BDD
          </Divider>
        </Space>
      </main>
    </Layout>
  )
}
