import Head from 'next/head'

import { Space, Typography, Collapse, Divider } from 'antd'

import Layout from 'components/Layout/Layout'

import styles from '../Topic.module.css'

export default function Architecture() {
  return (
    <Layout>
      <Head>
        <title>Architecture</title>
        <meta name='description' content='Generated by create next app' />
        <link rel='icon' href='/favicon.ico' />
      </Head>

      <main>
        <Space direction='vertical' className={styles.rootCard}>
          <Typography.Title level={3}>Architecture</Typography.Title>
          <Divider dashed={true} orientation='left'>
            What is Software Architecture?
          </Divider>
          <Typography.Text>
            Software architecture is the <b>process</b> of defining a{' '}
            <b>structured solution</b> that meets all of the <b>business</b>,{' '}
            <b>technical</b> and <b>operational</b> requirements. It involves a
            series of
            <b>decisions</b> based on a wide range of factors, and each of these
            decisions can have considerable <b>impact</b> on the <b>quality</b>.
          </Typography.Text>
          <Divider dashed={true} orientation='left'>
            Quality attributes
          </Divider>
          <Typography.Text>
            Quality attributes - set of characteristics by which we can measure{' '}
            the quality of our product. We can split those into 2 groups:{' '}
            Functional and Non-Functional requirements.
          </Typography.Text>
          <Collapse
            defaultActiveKey={['FRs', 'NFRs', 'priority', 'stackholders']}
          >
            <Collapse.Panel header='Functional requirements' key='FRs'>
              Functional requirements are requirements that are responsible for{' '}
              product functions/what product does/features.
            </Collapse.Panel>
            <Collapse.Panel header='Non-Functional requirements' key='NFRs'>
              <Space direction='vertical'>
                <Typography.Text>
                  Non Functional requirements are responsible for the way that{' '}
                  functionality is developed. We can split NFR into groups:{' '}
                  performance, compatibility, usability, reliability, security,{' '}
                  maintainability and portability.
                </Typography.Text>
                <Typography.Text>
                  We can sacrifice some of NFR in order to deliver FR faster and
                  NFR can occur during the development process.
                </Typography.Text>
              </Space>
            </Collapse.Panel>
            <Collapse.Panel
              header='Priority of functional and non-functional requirements'
              key='priority'
            >
              <Space direction='vertical'>
                <Typography.Text>
                  Priority of requirements can be set in a few ways. By business
                  analytics, by stakeholders, by government. Besides priority we
                  should also consider time-to-deliver criteria
                </Typography.Text>
                <Typography.Text>
                  For example, we can deliver 2 mid priority tasks instead 1
                  high priority and therefore gain more overall value.
                </Typography.Text>
              </Space>
            </Collapse.Panel>
            <Collapse.Panel header='Stakeholders' key='stackholders'>
              Stakeholders - are different groups of people that have interest
              in our product. It can be business, developers, third party
              services, end-users.
            </Collapse.Panel>
          </Collapse>
          <Divider dashed={true} orientation='left'>
            Best practices
          </Divider>
          <Collapse
            bordered={true}
            defaultActiveKey={[
              'SOLID',
              'SOC',
              'DRY',
              'KISS',
              'YAGNI',
              'composition&inheritance',
              'layers',
              'communication',
              'exceptions',
              'naming',
            ]}
          >
            <Collapse.Panel header='SOLID' key='SOLID'>
              <Divider dashed={true} orientation='left'>
                Single responsibility principle
              </Divider>
              <Typography.Text>
                There should be only one reason to change entity.
              </Typography.Text>
              <Divider dashed={true} orientation='left'>
                Open closed principle
              </Divider>
              <Typography.Text>
                Low level entries should not be available for modification, but
                they should be able to be extended by new entries
              </Typography.Text>
              <Divider dashed={true} orientation='left'>
                Liskov substitution principle
              </Divider>
              <Typography.Text>
                Entities that inherit some functionality should have same access
                interface.
              </Typography.Text>
              <Divider dashed={true} orientation='left'>
                Interface Segragation principle
              </Divider>
              <Typography.Text>
                Big amount of use-specific/client interfaces is better them big
                generic types for all cases.
              </Typography.Text>
              <Divider dashed={true} orientation='left'>
                Dependecy Inversion principle
              </Divider>
              <Typography.Text>
                High level entities should not rely on low level, instead they
                both should rely on abstraction.
              </Typography.Text>
            </Collapse.Panel>
            <Collapse.Panel header='Separation of concerns' key='SOC'>
              Principle, where we should split our application into chunks, that
              responsible for single certain concern
            </Collapse.Panel>
            <Collapse.Panel header='DRY' key='DRY'>
              Do not repeat yourself, code duplication, single source of truth
            </Collapse.Panel>
            <Collapse.Panel header='KISS' key='KISS'>
              Keep it stupid simple, easy code, easy to read, easy to understand
            </Collapse.Panel>
            <Collapse.Panel header='YAGNI' key='YAGNI'>
              You are not gonna need it, do not try to predict future use cases
            </Collapse.Panel>
            <Collapse.Panel
              header='Composition over Inheritance while Reusing the Functionality'
              key='composition&inheritance'
            >
              Composition is fp, inheritance is oop. When we use Inheritance we
              rely on inherited entities, we expect it to have some methods etc,
              hard to track those methods inheritances.
            </Collapse.Panel>
            <Collapse.Panel header='Logical layers' key='layers'>
              Approach, where we split our code, based on it's functionality/
              responsibility. It could be API request layer, application logical
              layer, ui layer. Applications can have several levels of such
              layers or it could be crossapp layers.
            </Collapse.Panel>
            <Collapse.Panel
              header='Communication Protocol, Data Format between Layers'
              key='communication'
            >
              The requirements come from NFR. We can have an API first approach,
              where we define data format before using it. Or if we have
              different backends with different communication formats we may
              consider creating backend for frontend, where we will align those
              formats.
            </Collapse.Panel>
            <Collapse.Panel
              header='Design Exceptions and Exception Handling Mechanism'
              key='exceptions'
            >
              Another NFR requirement, we may consider using react error
              boundaries, api interceptors if we need common request error
              handling, or if we want some specific handling we can handle it in
              component/saga.
            </Collapse.Panel>
            <Collapse.Panel header='Naming convention' key='naming'>
              Agreement between developers about the format in which we specify
              names/space etc. It can be influenced by technology that we are
              using(language, ecosystem, database, ci, etc). For javascript
              applications, we can use eslint/prettier in order to keep the
              required format.
            </Collapse.Panel>
          </Collapse>
        </Space>
      </main>
    </Layout>
  )
}
