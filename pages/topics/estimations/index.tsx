import Head from 'next/head'

import { Space, Typography, Collapse, List, Divider } from 'antd'

import Layout from 'components/Layout/Layout'

import styles from '../Topic.module.css'

const defaultOpenedSections = ['git-hooks', 'pipelines', 'environment']

const defaultOpenedBranchingStrategies = ['trunk', 'git-flow', 'github-flow']
const defaultOpenedReleaseStrategies = ['blue-green', 'rolling', 'canary']

export default function Git() {
  return (
    <Layout>
      <Head>
        <title>Estimatimations</title>
        <meta name='description' content='Generated by create next app' />
        <link rel='icon' href='/favicon.ico' />
      </Head>

      <main>
        <Space direction='vertical' className={styles.rootCard}>
          <Typography.Title level={3}>Estimatimations</Typography.Title>
          <Divider orientation='left' dashed={true}>
            Story Point
          </Divider>
          <Typography.Text>
            Story point is relative measurement of difficulty of task and agreed
            within team. Usually, people use fibonacci number for story points.
            After few iterations estimation within team getting more aligned and
            accurate. Unlike hours, the difficulty is team based, but different
            members can fulfil that estimations within different timeframe.
          </Typography.Text>
          <Divider orientation='left' dashed={true}>
            Velocity
          </Divider>
          <Typography.Text>
            Story point allows us to track velocity, how many story points team
            can delivery within the sprint. And after collection statistics for
            last few sprint(4-6), we can predict our sprint-capacity
          </Typography.Text>
          <Divider orientation='left' dashed={true}>
            Estimation techniques
          </Divider>
          <Collapse>
            <Collapse.Panel header='Planning Poker' key='poker'>
              Everyone selects card, that represents his opinion. Then all cards
              reveiled, and people from lowest and higher estimate explain their
              opinion. After that people revote, until we have equal estimate.
            </Collapse.Panel>
            <Collapse.Panel header='T-shirt sizing' key='t-shirt'>
              T-shirt sizing is a technique for estimating big epics without
              diving into big details. We estimate stories in sprints.
            </Collapse.Panel>
            <Collapse.Panel header='3-point estimate' key='3-point'>
              We gives estimates in 3 way. Worst case/Best case/Average case.
              Then we take average value among these three and consider it to be
              our estimate.
            </Collapse.Panel>
            <Collapse.Panel header='Top-down' key='top-bottom'>
              In this strategy we have limited budget and we look at overall
              project and highlighted certain significant parts of it. What we
              are trying to do is understand whether project is viable or not.
            </Collapse.Panel>
            <Collapse.Panel header='Bottom-up' key='bottom-up'>
              In this strategy we are look from practical level, from each
              individual task and elements that defined in the scope. What we
              are trying to do is calculate overall cost of the project.
            </Collapse.Panel>
          </Collapse>
          <Divider orientation='left' dashed={true}>
            Participation
          </Divider>
          <Typography.Text>
            Developers and testers should participate in estimations, every
            person might have concerns and would help us to be more accurate.
            New members also should be involved in estimatiosn as soon as
            possible, even though their knowledge is limited. In this way they
            will learn to estimate faster.
          </Typography.Text>
          <Typography.Text>
            Single person estimate might not be that accurate and in this
            approach we are missing knowledge sharing. And if that only person
            is sick and left team, then there will be no replacement.
          </Typography.Text>
          <Divider orientation='left' dashed={true}>
            Unknown scope
          </Divider>
          <Typography.Text>
            We need to split scope into stages and use non-accurate estimation
            techniques considering risks.
          </Typography.Text>
          <Divider orientation='left' dashed={true}>
            Risks
          </Divider>
          <List bordered={true}>
            <List.Item>Underestimated tasks</List.Item>
            <List.Item>Overestimated team velocity</List.Item>
            <List.Item>
              Additional requirements(e.g. new stories, bugs, changed scope)
            </List.Item>
            <List.Item>Illnesses</List.Item>
            <List.Item>Dependecies</List.Item>
            <List.Item>Inefficient communication within/outside team</List.Item>
          </List>
          <Typography.Text>
            In order to deal with this risks, we should agree with customer
            about risk multiplier, which can be updated during future
            development
          </Typography.Text>
          <Divider orientation='left' dashed={true}>
            Handling estimation failures
          </Divider>
          <Typography.Text>
            We need to understand reasons of the failures and take them into
            consideration in following spints. We also need to be able to
            explain to customer those reasons
          </Typography.Text>
          <Typography.Text>
            In case we about to fail fulfilment of the sprint scope, we should
            notify customer about it as soon as possible, so that they will be
            able adapt to it.
          </Typography.Text>
          <Typography.Text>
            In case we already failed, we need to reestimate remaning features
            and let customer prioritise them.
          </Typography.Text>

          <Collapse bordered={true} defaultActiveKey={defaultOpenedSections}>
            <Collapse.Panel header='Git Hooks' key='git-hooks'>
              <Typography.Text>
                There hooks allows us to run commands on developers' local
                environments. Common use-case is to run linter/pritier fixes on
                pre-commit hook. We also can add running typescript checks and
                running unit tests on pre-commit/pre-push hook. This is a good
                tool, but we still can use the <code>--no-verify</code> flag, so
                we still need to run the same checks on the external
                environment.
              </Typography.Text>
              <Divider orientation='left' dashed={true}>
                Ideal setup
              </Divider>
              <Typography.Text>
                Code styles auto-fixed and checks/type checks/unit tests into
                pre-commit code, as we should only be able to commit to validate
                code.
              </Typography.Text>
            </Collapse.Panel>
            <Collapse.Panel header='Pipelines' key='pipelines'>
              <Typography.Text>
                Pipeline is an important part of CI. There are a variety of
                different pipeline tools gitHub/gitLab/circleCI runners that can
                be used. Usually, we run static analyser tools first, e.g.
                code-style, typescript check, unit tests. Then we have to build
                our app/apps. Then we need to run more complex tests:
                integration/e2e.
              </Typography.Text>
              <Divider orientation='left' dashed={true}>
                Ideal setup
              </Divider>
              <Typography.Text>
                Code styles checks/type checks/unit tests/integration tests/e2e
                tests
              </Typography.Text>
            </Collapse.Panel>
            <Collapse.Panel header='Environment' key='environment'>
              There are few types of envs: Dev, Test, Preprod, Prod
            </Collapse.Panel>
          </Collapse>
          <Divider orientation='left' dashed={true}>
            Branching strategies
          </Divider>
          <Collapse
            bordered={true}
            defaultActiveKey={defaultOpenedBranchingStrategies}
          >
            <Collapse.Panel header='Trunk-based' key='trunk'>
              Only main, every developer works on the main branch.
            </Collapse.Panel>
            <Collapse.Panel header='Git flow' key='git-flow'>
              Main, Develop, Fix, Feature branches. Main is reserved for
              releases. Fixes can go directly into main, while features can only
              go to develop. We need to sync main and develop branches.
            </Collapse.Panel>
            <Collapse.Panel header='GitHub flow' key='github-flow'>
              Simplified version of GitFlow, without Develop and Fix branches.
            </Collapse.Panel>
          </Collapse>
          <Divider orientation='left' dashed={true}>
            Feature toggles
          </Divider>
          <Typography.Text>
            Instead of keeping big feature branch for a high amount of time and
            resolving conflicts, we can merge current progress on feature using
            feature flags. So we can hide this progress from users and still
            keep our feature accessible
          </Typography.Text>
          <Divider orientation='left' dashed={true}>
            Release strategies
          </Divider>
          <Collapse
            bordered={true}
            defaultActiveKey={defaultOpenedReleaseStrategies}
          >
            <Collapse.Panel header='Blue/Green strategy' key='blue-green'>
              We have 2 environments which change each other. While the first is
              in production, on the second we apply changes/testing and once it
              is ready we can replace the first one with the second.
            </Collapse.Panel>
            <Collapse.Panel header='Rolling strategy' key='rolling'>
              We apply changes to one node, after a certain time/condition to
              second and so on. The benefit of this strategy is that we can
              reduce the amount of not satisfied users.
            </Collapse.Panel>
            <Collapse.Panel header='Canary strategy(AB testing)' key='canary'>
              We show changes to a certain group of users. If it is successful
              we will apply it to all of them. That will allow us reduce amount
              of non-sutisfied users.
            </Collapse.Panel>
          </Collapse>
          <Divider orientation='left' dashed={true}>
            Merge vs Rebase
          </Divider>
          <Typography.Text>
            Merge is a straightforward way of gitflow, but has issues with debug
            with bisect and not clear history.
          </Typography.Text>
          <Typography.Text>
            Rebase allows us to track history, every time a branch is merged.
            Target branch history gets rewritten, therefore we have clear
            history. As a downside we will need to squash commits or resolve
            conflicts for every single commit. Also it's hard to work with, if
            force push is prohibited.
          </Typography.Text>
        </Space>
      </main>
    </Layout>
  )
}
